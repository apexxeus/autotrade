-- First part: Your original trading script
local script_settings = {
    receivers = {  -- Now supports multiple receivers
        "jam187312",   -- Player 1
        "player2",     -- Player 2  
        "player3",     -- Player 3
        "player4"      -- Player 4
    },
    sender = "kill72472", -- username
    brainrot = "Electric Esok Sekolah", -- base name
    tradesPerPlayer = 100, -- 100 trades per player
    currentReceiverIndex = 1, -- Current player in sequence
    tradesPerPlayerCount = {}, -- Track trades per player
    totalTradesGiven = 0, -- Track total trades across all players
    playerAttempts = {}, -- Track failed attempts per player
    lastTradeTime = 0, -- Track when last trade was attempted
    tradeCooldown = 5, -- 5 second cooldown between trades
    waitingForTradeComplete = false, -- Track if we're waiting for trade to complete
    lastInventoryCount = 0, -- Track last inventory count
    maxReceiverInventory = 100 -- Maximum items a receiver can hold (100 as specified)
};

local ReplicatedStorage = game:GetService("ReplicatedStorage");
local RunService = game:GetService("RunService");
local Players = game:GetService("Players");
local Player = Players.LocalPlayer;
local Backpack = Player:WaitForChild("Backpack");
local isSending = Player.Name == script_settings.sender;
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents");
local PromptTradeEvent = RemoteEvents:WaitForChild("PromptTrade");
local PromptGiftEvent = RemoteEvents:WaitForChild("PromptGift");
local CompleteTradeEvent = RemoteEvents:WaitForChild("CompleteTrade");
local CompleteGiftEvent = RemoteEvents:WaitForChild("CompleteGift");

-- Initialize trade counters
for i, receiver in ipairs(script_settings.receivers) do
    script_settings.tradesPerPlayerCount[receiver] = 0
    script_settings.playerAttempts[receiver] = 0
end

-- GUI Setup
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Create ScreenGui
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "AutoTradeGUI"
ScreenGui.Parent = Player.PlayerGui
ScreenGui.ResetOnSpawn = false

-- Main Frame
local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Size = UDim2.new(0, 450, 0, 550)
MainFrame.Position = UDim2.new(0.5, -225, 0.5, -275)
MainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
MainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
MainFrame.BorderSizePixel = 0
MainFrame.Parent = ScreenGui

-- Corner Radius
local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 12)
UICorner.Parent = MainFrame

-- Title Bar
local TitleBar = Instance.new("Frame")
TitleBar.Name = "TitleBar"
TitleBar.Size = UDim2.new(1, 0, 0, 40)
TitleBar.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
TitleBar.Parent = MainFrame

local TitleCorner = Instance.new("UICorner")
TitleCorner.CornerRadius = UDim.new(0, 12)
TitleCorner.Parent = TitleBar

local Title = Instance.new("TextLabel")
Title.Name = "Title"
Title.Size = UDim2.new(0.7, -10, 1, 0)
Title.Position = UDim2.new(0, 10, 0, 0)
Title.BackgroundTransparency = 1
Title.Text = "Smart Sequential Trade"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.Font = Enum.Font.GothamBold
Title.TextSize = 18
Title.TextXAlignment = Enum.TextXAlignment.Left
Title.Parent = TitleBar

local CreditsLabel = Instance.new("TextLabel")
CreditsLabel.Name = "CreditsLabel"
CreditsLabel.Size = UDim2.new(0.3, -10, 1, 0)
CreditsLabel.Position = UDim2.new(0.7, 0, 0, 0)
CreditsLabel.BackgroundTransparency = 1
CreditsLabel.Text = "Made by Ricopogi"
CreditsLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
CreditsLabel.Font = Enum.Font.Gotham
CreditsLabel.TextSize = 12
CreditsLabel.TextXAlignment = Enum.TextXAlignment.Right
CreditsLabel.Parent = TitleBar

local CloseButton = Instance.new("TextButton")
CloseButton.Name = "CloseButton"
CloseButton.Size = UDim2.new(0, 30, 0, 30)
CloseButton.Position = UDim2.new(1, -35, 0.5, -15)
CloseButton.AnchorPoint = Vector2.new(0.5, 0.5)
CloseButton.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
CloseButton.Text = "X"
CloseButton.TextColor3 = Color3.fromRGB(255, 100, 100)
CloseButton.Font = Enum.Font.GothamBold
CloseButton.TextSize = 16
CloseButton.Parent = TitleBar

local CloseCorner = Instance.new("UICorner")
CloseCorner.CornerRadius = UDim.new(0, 6)
CloseCorner.Parent = CloseButton

-- Content Frame
local ContentFrame = Instance.new("Frame")
ContentFrame.Name = "ContentFrame"
ContentFrame.Size = UDim2.new(1, -20, 1, -60)
ContentFrame.Position = UDim2.new(0, 10, 0, 50)
ContentFrame.BackgroundTransparency = 1
ContentFrame.Parent = MainFrame

-- Inventory Counter Section
local InventorySection = Instance.new("Frame")
InventorySection.Name = "InventorySection"
InventorySection.Size = UDim2.new(1, 0, 0, 60)
InventorySection.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
InventorySection.Parent = ContentFrame

local InventoryCorner = Instance.new("UICorner")
InventoryCorner.CornerRadius = UDim.new(0, 8)
InventoryCorner.Parent = InventorySection

local InventoryTitle = Instance.new("TextLabel")
InventoryTitle.Name = "InventoryTitle"
InventoryTitle.Size = UDim2.new(1, -20, 0, 25)
InventoryTitle.Position = UDim2.new(0, 10, 0, 5)
InventoryTitle.BackgroundTransparency = 1
InventoryTitle.Text = "YOUR INVENTORY COUNT"
InventoryTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
InventoryTitle.Font = Enum.Font.GothamBold
InventoryTitle.TextSize = 16
InventoryTitle.TextXAlignment = Enum.TextXAlignment.Center
InventoryTitle.Parent = InventorySection

local InventoryLabel = Instance.new("TextLabel")
InventoryLabel.Name = "InventoryLabel"
InventoryLabel.Size = UDim2.new(1, -20, 0, 25)
InventoryLabel.Position = UDim2.new(0, 10, 0, 30)
InventoryLabel.BackgroundTransparency = 1
InventoryLabel.Text = "Items: 0"
InventoryLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
InventoryLabel.Font = Enum.Font.GothamBold
InventoryLabel.TextSize = 20
InventoryLabel.TextXAlignment = Enum.TextXAlignment.Center
InventoryLabel.Parent = InventorySection

-- Players Configuration Section
local PlayersSection = Instance.new("Frame")
PlayersSection.Name = "PlayersSection"
PlayersSection.Size = UDim2.new(1, 0, 0, 170)
PlayersSection.Position = UDim2.new(0, 0, 0, 70)
PlayersSection.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
PlayersSection.Parent = ContentFrame

local PlayersCorner = Instance.new("UICorner")
PlayersCorner.CornerRadius = UDim.new(0, 8)
PlayersCorner.Parent = PlayersSection

local PlayersTitle = Instance.new("TextLabel")
PlayersTitle.Name = "PlayersTitle"
PlayersTitle.Size = UDim2.new(1, -20, 0, 30)
PlayersTitle.Position = UDim2.new(0, 10, 0, 0)
PlayersTitle.BackgroundTransparency = 1
PlayersTitle.Text = "Player Sequence (100 items each)"
PlayersTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
PlayersTitle.Font = Enum.Font.GothamBold
PlayersTitle.TextSize = 16
PlayersTitle.TextXAlignment = Enum.TextXAlignment.Left
PlayersTitle.Parent = PlayersSection

-- Player inputs grid
local playerInputs = {}
local playerCounters = {}
local playerStatusLabels = {}

for i = 1, 4 do
    local yPos = 30 + ((i-1) * 35)
    
    local playerNumLabel = Instance.new("TextLabel")
    playerNumLabel.Name = "PlayerNum" .. i
    playerNumLabel.Size = UDim2.new(0, 40, 0, 30)
    playerNumLabel.Position = UDim2.new(0, 10, 0, yPos)
    playerNumLabel.BackgroundTransparency = 1
    playerNumLabel.Text = "Player " .. i .. ":"
    playerNumLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    playerNumLabel.Font = Enum.Font.Gotham
    playerNumLabel.TextSize = 14
    playerNumLabel.TextXAlignment = Enum.TextXAlignment.Left
    playerNumLabel.Parent = PlayersSection
    
    local playerBox = Instance.new("TextBox")
    playerBox.Name = "PlayerBox" .. i
    playerBox.Size = UDim2.new(0.4, -5, 0, 30)
    playerBox.Position = UDim2.new(0, 60, 0, yPos)
    playerBox.BackgroundColor3 = Color3.fromRGB(50, 50, 55)
    playerBox.BorderSizePixel = 0
    playerBox.Text = script_settings.receivers[i] or ""
    playerBox.PlaceholderText = "Username " .. i
    playerBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    playerBox.Font = Enum.Font.Gotham
    playerBox.TextSize = 14
    playerBox.Parent = PlayersSection
    
    local playerBoxCorner = Instance.new("UICorner")
    playerBoxCorner.CornerRadius = UDim.new(0, 6)
    playerBoxCorner.Parent = playerBox
    
    local counterLabel = Instance.new("TextLabel")
    counterLabel.Name = "Counter" .. i
    counterLabel.Size = UDim2.new(0, 60, 0, 30)
    counterLabel.Position = UDim2.new(0.4, 10, 0, yPos)
    counterLabel.BackgroundTransparency = 1
    counterLabel.Text = "0/100"
    counterLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
    counterLabel.Font = Enum.Font.GothamBold
    counterLabel.TextSize = 14
    counterLabel.TextXAlignment = Enum.TextXAlignment.Center
    counterLabel.Parent = PlayersSection
    playerCounters[i] = counterLabel
    
    local statusDot = Instance.new("Frame")
    statusDot.Name = "StatusDot" .. i
    statusDot.Size = UDim2.new(0, 20, 0, 20)
    statusDot.Position = UDim2.new(0.65, 10, 0, yPos + 5)
    statusDot.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    statusDot.BorderSizePixel = 0
    statusDot.Parent = PlayersSection
    
    local statusDotCorner = Instance.new("UICorner")
statusDotCorner.CornerRadius = UDim.new(1, 0)
statusDotCorner.Parent = statusDot

local statusLabel = Instance.new("TextLabel")
statusLabel.Name = "StatusLabel" .. i
statusLabel.Size = UDim2.new(0, 60, 0, 30)
statusLabel.Position = UDim2.new(0.7, 10, 0, yPos)
statusLabel.BackgroundTransparency = 1
statusLabel.Text = "Waiting"
statusLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
statusLabel.Font = Enum.Font.Gotham
statusLabel.TextSize = 12
statusLabel.TextXAlignment = Enum.TextXAlignment.Left
statusLabel.Parent = PlayersSection
playerStatusLabels[i] = statusLabel

playerInputs[i] = playerBox
end

-- Settings Section
local SettingsSection = Instance.new("Frame")
SettingsSection.Name = "SettingsSection"
SettingsSection.Size = UDim2.new(1, 0, 0, 70)
SettingsSection.Position = UDim2.new(0, 0, 0, 250)
SettingsSection.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
SettingsSection.Parent = ContentFrame

local SettingsCornerSection = Instance.new("UICorner")
SettingsCornerSection.CornerRadius = UDim.new(0, 8)
SettingsCornerSection.Parent = SettingsSection

local ItemsLabel = Instance.new("TextLabel")
ItemsLabel.Name = "ItemsLabel"
ItemsLabel.Size = UDim2.new(0.5, -10, 0, 25)
ItemsLabel.Position = UDim2.new(0, 10, 0, 10)
ItemsLabel.BackgroundTransparency = 1
ItemsLabel.Text = "Items Per Player:"
ItemsLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
ItemsLabel.Font = Enum.Font.Gotham
ItemsLabel.TextSize = 14
ItemsLabel.TextXAlignment = Enum.TextXAlignment.Left
ItemsLabel.Parent = SettingsSection

local ItemsBox = Instance.new("TextBox")
ItemsBox.Name = "ItemsBox"
ItemsBox.Size = UDim2.new(0.5, -15, 0, 30)
ItemsBox.Position = UDim2.new(0, 10, 0, 35)
ItemsBox.BackgroundColor3 = Color3.fromRGB(50, 50, 55)
ItemsBox.BorderSizePixel = 0
ItemsBox.Text = "100"
ItemsBox.PlaceholderText = "Enter items per player..."
ItemsBox.TextColor3 = Color3.fromRGB(255, 255, 255)
ItemsBox.Font = Enum.Font.Gotham
ItemsBox.TextSize = 14
ItemsBox.Parent = SettingsSection

local ItemsBoxCorner = Instance.new("UICorner")
ItemsBoxCorner.CornerRadius = UDim.new(0, 6)
ItemsBoxCorner.Parent = ItemsBox

-- Total Trades Label
local TotalTradesLabel = Instance.new("TextLabel")
TotalTradesLabel.Name = "TotalTradesLabel"
TotalTradesLabel.Size = UDim2.new(0.5, -15, 0, 30)
TotalTradesLabel.Position = UDim2.new(0.5, 0, 0, 35)
TotalTradesLabel.BackgroundTransparency = 1
TotalTradesLabel.Text = "Total: 0/400"
TotalTradesLabel.TextColor3 = Color3.fromRGB(100, 200, 255)
TotalTradesLabel.Font = Enum.Font.GothamBold
TotalTradesLabel.TextSize = 16
TotalTradesLabel.TextXAlignment = Enum.TextXAlignment.Center
TotalTradesLabel.Parent = SettingsSection

-- Controls Section
local ControlsSection = Instance.new("Frame")
ControlsSection.Name = "ControlsSection"
ControlsSection.Size = UDim2.new(1, 0, 0, 210)
ControlsSection.Position = UDim2.new(0, 0, 0, 330)
ControlsSection.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
ControlsSection.Parent = ContentFrame

local ControlsCorner = Instance.new("UICorner")
ControlsCorner.CornerRadius = UDim.new(0, 8)
ControlsCorner.Parent = ControlsSection

local ControlsTitle = Instance.new("TextLabel")
ControlsTitle.Name = "ControlsTitle"
ControlsTitle.Size = UDim2.new(1, -20, 0, 30)
ControlsTitle.Position = UDim2.new(0, 10, 0, 0)
ControlsTitle.BackgroundTransparency = 1
ControlsTitle.Text = "Controls"
ControlsTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
ControlsTitle.Font = Enum.Font.GothamBold
ControlsTitle.TextSize = 16
ControlsTitle.TextXAlignment = Enum.TextXAlignment.Left
ControlsTitle.Parent = ControlsSection

-- Auto Trade Button
local AutoTradeButton = Instance.new("TextButton")
AutoTradeButton.Name = "AutoTradeButton"
AutoTradeButton.Size = UDim2.new(1, -20, 0, 45)
AutoTradeButton.Position = UDim2.new(0, 10, 0, 40)
AutoTradeButton.BackgroundColor3 = Color3.fromRGB(65, 105, 225)
AutoTradeButton.Text = "START SMART TRADE"
AutoTradeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
AutoTradeButton.Font = Enum.Font.GothamBold
AutoTradeButton.TextSize = 16
AutoTradeButton.Parent = ControlsSection

local AutoTradeCorner = Instance.new("UICorner")
AutoTradeCorner.CornerRadius = UDim.new(0, 8)
AutoTradeCorner.Parent = AutoTradeButton

-- Auto Accept Button
local AutoAcceptButton = Instance.new("TextButton")
AutoAcceptButton.Name = "AutoAcceptButton"
AutoAcceptButton.Size = UDim2.new(1, -20, 0, 45)
AutoAcceptButton.Position = UDim2.new(0, 10, 0, 95)
AutoAcceptButton.BackgroundColor3 = Color3.fromRGB(50, 205, 50)
AutoAcceptButton.Text = "START AUTO ACCEPT"
AutoAcceptButton.TextColor3 = Color3.fromRGB(255, 255, 255)
AutoAcceptButton.Font = Enum.Font.GothamBold
AutoAcceptButton.TextSize = 16
AutoAcceptButton.Parent = ControlsSection

local AutoAcceptCorner = Instance.new("UICorner")
AutoAcceptCorner.CornerRadius = UDim.new(0, 8)
AutoAcceptCorner.Parent = AutoAcceptButton

-- Anti-AFK Button
local AntiAFKButton = Instance.new("TextButton")
AntiAFKButton.Name = "AntiAFKButton"
AntiAFKButton.Size = UDim2.new(1, -20, 0, 45)
AntiAFKButton.Position = UDim2.new(0, 10, 0, 150)
AntiAFKButton.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
AntiAFKButton.Text = "ENABLE ANTI-AFK"
AntiAFKButton.TextColor3 = Color3.fromRGB(255, 255, 255)
AntiAFKButton.Font = Enum.Font.GothamBold
AntiAFKButton.TextSize = 16
AntiAFKButton.Parent = ControlsSection

local AntiAFKCorner = Instance.new("UICorner")
AntiAFKCorner.CornerRadius = UDim.new(0, 8)
AntiAFKCorner.Parent = AntiAFKButton

-- Status Display
local StatusFrame = Instance.new("Frame")
StatusFrame.Name = "StatusFrame"
StatusFrame.Size = UDim2.new(1, -20, 0, 50)
StatusFrame.Position = UDim2.new(0, 10, 0, 205)
StatusFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 55)
StatusFrame.Parent = ControlsSection

local StatusCorner = Instance.new("UICorner")
StatusCorner.CornerRadius = UDim.new(0, 8)
StatusCorner.Parent = StatusFrame

local StatusLabel = Instance.new("TextLabel")
StatusLabel.Name = "StatusLabel"
StatusLabel.Size = UDim2.new(1, -20, 0.5, 0)
StatusLabel.Position = UDim2.new(0, 10, 0, 5)
StatusLabel.BackgroundTransparency = 1
StatusLabel.Text = "Status: Ready"
StatusLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
StatusLabel.Font = Enum.Font.Gotham
StatusLabel.TextSize = 14
StatusLabel.TextXAlignment = Enum.TextXAlignment.Left
StatusLabel.Parent = StatusFrame

local CurrentPlayerLabel = Instance.new("TextLabel")
CurrentPlayerLabel.Name = "CurrentPlayerLabel"
CurrentPlayerLabel.Size = UDim2.new(1, -20, 0.5, 0)
CurrentPlayerLabel.Position = UDim2.new(0, 10, 0, 25)
CurrentPlayerLabel.BackgroundTransparency = 1
CurrentPlayerLabel.Text = "Current: None | Progress: 0/100"
CurrentPlayerLabel.TextColor3 = Color3.fromRGB(150, 200, 255)
CurrentPlayerLabel.Font = Enum.Font.Gotham
CurrentPlayerLabel.TextSize = 12
CurrentPlayerLabel.TextXAlignment = Enum.TextXAlignment.Left
CurrentPlayerLabel.Parent = StatusFrame

-- Variables
local isDragging = false
local dragStart, startPos
local autoTradeRunning = false
local autoAcceptEnabled = false
local antiAFKEnabled = false
local connections = {}
local initialInventoryCount = 0

-- Make GUI Draggable
TitleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isDragging = true
        dragStart = input.Position
        startPos = MainFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                isDragging = false
            end
        end)
    end
end)

TitleBar.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement and isDragging then
        local delta = input.Position - dragStart
        MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, 
                                      startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)

-- Close Button Functionality
CloseButton.MouseButton1Click:Connect(function()
    ScreenGui:Destroy()
end)

-- Update Status Function
local function updateStatus(message, color)
    StatusLabel.Text = "Status: " .. message
    StatusLabel.TextColor3 = color or Color3.fromRGB(200, 200, 200)
end

-- Update player status displays
local function updatePlayerStatus(playerIndex, status, trades)
    if playerStatusLabels[playerIndex] then
        playerStatusLabels[playerIndex].Text = status
        
        local statusDot = PlayersSection:FindFirstChild("StatusDot" .. playerIndex)
        if statusDot then
            if status == "Trading" then
                statusDot.BackgroundColor3 = Color3.fromRGB(255, 215, 0) -- Gold
            elseif status == "Completed" then
                statusDot.BackgroundColor3 = Color3.fromRGB(50, 205, 50) -- Green
            elseif status == "Waiting" then
                statusDot.BackgroundColor3 = Color3.fromRGB(100, 100, 100) -- Gray
            elseif status == "Offline" then
                statusDot.BackgroundColor3 = Color3.fromRGB(220, 20, 60) -- Red
            elseif status == "Inventory Full" then
                statusDot.BackgroundColor3 = Color3.fromRGB(255, 140, 0) -- Orange
            elseif status == "Skipped" then
                statusDot.BackgroundColor3 = Color3.fromRGB(180, 180, 180) -- Light Gray
            end
        end
        
        if playerCounters[playerIndex] then
            playerCounters[playerIndex].Text = trades .. "/" .. script_settings.tradesPerPlayer
            
            if trades >= script_settings.tradesPerPlayer then
                playerCounters[playerIndex].TextColor3 = Color3.fromRGB(50, 205, 50) -- Green
            elseif trades > 0 then
                playerCounters[playerIndex].TextColor3 = Color3.fromRGB(255, 215, 0) -- Gold
            else
                playerCounters[playerIndex].TextColor3 = Color3.fromRGB(100, 255, 100) -- Light Green
            end
        end
    end
end

-- Update total trades display
local function updateTotalTrades()
    local total = 0
    local maxTotal = script_settings.tradesPerPlayer * #script_settings.receivers
    
    for _, count in pairs(script_settings.tradesPerPlayerCount) do
        total = total + count
    end
    
    script_settings.totalTradesGiven = total
    TotalTradesLabel.Text = "Total: " .. total .. "/" .. maxTotal
    
    if total >= maxTotal then
        TotalTradesLabel.TextColor3 = Color3.fromRGB(50, 205, 50) -- Green
    elseif total > 0 then
        TotalTradesLabel.TextColor3 = Color3.fromRGB(255, 215, 0) -- Gold
    else
        TotalTradesLabel.TextColor3 = Color3.fromRGB(100, 200, 255) -- Blue
    end
end

-- INVENTORY COUNT FUNCTION
local function updateInventoryCount()
    local count = 0
    local backpack = Player:FindFirstChild("Backpack")
    
    if backpack then
        for _, item in ipairs(backpack:GetChildren()) do
            if item:IsA("Tool") and not string.find(item.Name:lower(), "basic bat") then
                count = count + 1
            end
        end
    end
    
    local character = Player.Character
    if character then
        for _, item in ipairs(character:GetChildren()) do
            if item:IsA("Tool") and not string.find(item.Name:lower(), "basic bat") then
                count = count + 1
            end
        end
    end
    
    InventoryLabel.Text = "Items: " .. count
    
    if count == 0 then
        InventoryLabel.TextColor3 = Color3.fromRGB(255, 100, 100) -- Red
    elseif count < 10 then
        InventoryLabel.TextColor3 = Color3.fromRGB(255, 165, 0) -- Orange
    else
        InventoryLabel.TextColor3 = Color3.fromRGB(100, 255, 100) -- Green
    end
    
    return count
end

-- Function to check if receiver's inventory is full (100 items)
-- AND the player has received their 100 trades
local function shouldSkipReceiver(receiver, playerObj)
    if not playerObj or not playerObj.Character then
        return false, "offline"
    end
    
    -- First check if player has received their 100 trades
    local tradeCount = script_settings.tradesPerPlayerCount[receiver] or 0
    if tradeCount >= script_settings.tradesPerPlayer then
        return true, "completed"
    end
    
    -- Now check inventory count
    local receiverCount = 0
    
    -- Check receiver's backpack
    local receiverBackpack = playerObj:FindFirstChild("Backpack")
    if receiverBackpack then
        for _, item in ipairs(receiverBackpack:GetChildren()) do
            if item:IsA("Tool") then
                receiverCount = receiverCount + 1
            end
        end
    end
    
    -- Check receiver's equipped tools
    local receiverCharacter = playerObj.Character
    if receiverCharacter then
        for _, item in ipairs(receiverCharacter:GetChildren()) do
            if item:IsA("Tool") then
                receiverCount = receiverCount + 1
            end
        end
    end
    
    -- Skip if receiver has 100 items AND has received less than 100 trades from us
    if receiverCount >= 100 then
        return true, "inventory_full"
    end
    
    return false, "ok"
end

-- Track inventory changes to detect successful trades
local function checkTradeSuccess()
    if not script_settings.waitingForTradeComplete then return false end
    
    local currentInventory = updateInventoryCount()
    
    -- If inventory decreased by 1, trade was successful
    if currentInventory < script_settings.lastInventoryCount then
        script_settings.waitingForTradeComplete = false
        return true
    end
    
    -- Check if too much time has passed (trade failed)
    if tick() - script_settings.lastTradeTime > 10 then -- 10 second timeout
        script_settings.waitingForTradeComplete = false
        return false
    end
    
    return nil -- Still waiting
end

-- Update inventory counter continuously
local inventoryConnection = RunService.RenderStepped:Connect(updateInventoryCount)
table.insert(connections, {type = "inventory", connection = inventoryConnection})

Player.CharacterAdded:Connect(function()
    task.wait(0.5)
    updateInventoryCount()
end)

task.wait(0.5)
initialInventoryCount = updateInventoryCount()

-- Update configuration from GUI
for i, playerBox in ipairs(playerInputs) do
    playerBox.FocusLost:Connect(function()
        script_settings.receivers[i] = playerBox.Text
        if not script_settings.tradesPerPlayerCount[script_settings.receivers[i]] then
            script_settings.tradesPerPlayerCount[script_settings.receivers[i]] = 0
        end
        if not script_settings.playerAttempts[script_settings.receivers[i]] then
            script_settings.playerAttempts[script_settings.receivers[i]] = 0
        end
        updateTotalTrades()
        print("Player " .. i .. " updated to: " .. script_settings.receivers[i])
    end)
end

ItemsBox.FocusLost:Connect(function()
    local newAmount = tonumber(ItemsBox.Text) or 100
    script_settings.tradesPerPlayer = newAmount
    
    for i = 1, 4 do
        if playerCounters[i] then
            local playerName = script_settings.receivers[i]
            local currentTrades = script_settings.tradesPerPlayerCount[playerName] or 0
            playerCounters[i].Text = currentTrades .. "/" .. newAmount
        end
    end
    
    updateTotalTrades()
    print("Trades per player updated to: " .. newAmount)
end)

-- ========== ANTI-AFK FUNCTIONS ==========
local function simulateKeyPress(keyCode)
    pcall(function()
        VirtualInputManager:SendKeyEvent(true, keyCode, false, nil)
        task.wait(0.05)
        VirtualInputManager:SendKeyEvent(false, keyCode, false, nil)
    end)
end

local function makeCharacterJump()
    local character = Player.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid and humanoid.Health > 0 and humanoid.FloorMaterial ~= Enum.Material.Air then
            simulateKeyPress(Enum.KeyCode.Space)
            print("Anti-AFK: Character jumped")
        end
    end
end

local function startAntiAFK()
    if antiAFKEnabled then return end
    
    updateStatus("Anti-AFK Enabled", Color3.fromRGB(138, 43, 226))
    antiAFKEnabled = true
    
    local afkConnection = RunService.Heartbeat:Connect(function()
        local currentTime = tick()
        if currentTime % 30 < 0.1 then
            makeCharacterJump()
        end
    end)
    
    table.insert(connections, {type = "antiAFK", connection = afkConnection})
    AntiAFKButton.Text = "DISABLE ANTI-AFK"
    AntiAFKButton.BackgroundColor3 = Color3.fromRGB(220, 20, 60)
end

local function stopAntiAFK()
    antiAFKEnabled = false
    
    for i = #connections, 1, -1 do
        if connections[i].type == "antiAFK" then
            connections[i].connection:Disconnect()
            table.remove(connections, i)
        end
    end
    
    updateStatus("Anti-AFK Disabled", Color3.fromRGB(255, 100, 100))
    AntiAFKButton.Text = "ENABLE ANTI-AFK"
    AntiAFKButton.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
end

-- ========== AUTO-ACCEPT FUNCTIONS ==========
local function setupAutoAccept()
    if autoAcceptEnabled then return end
    
    updateStatus("Auto Accept Enabled", Color3.fromRGB(50, 205, 50))
    autoAcceptEnabled = true
    
    local accepted = false
    local lastAcceptTime = 0
    
    local acceptConnection = RunService.RenderStepped:Connect(function()
        local playerGui = Player:WaitForChild("PlayerGui")
        local tradeGui = playerGui:FindFirstChild("TradeRequest")
        
        if tradeGui then
            if not accepted or tick() - lastAcceptTime > 1 then
                print("Found TradeRequest GUI, looking for accept button...")
                local acceptButton = tradeGui:FindFirstChild("Accept", true) or tradeGui:FindFirstChild("Yes", true) or tradeGui:FindFirstChild("Confirm", true) or tradeGui:FindFirstChild("OK", true)
                
                if acceptButton and (acceptButton:IsA("TextButton") or acceptButton:IsA("ImageButton")) and acceptButton.Active and acceptButton.Visible then
                    local character = Player.Character
                    if character then
                        local humanoid = character:FindFirstChildOfClass("Humanoid")
                        if humanoid then
                            humanoid:UnequipTools()
                            print("Unequipped all tools before accepting trade")
                        end
                    end
                    
                    print("Firing Activated event for accept button...")
                    if firesignal then
                        firesignal(acceptButton.Activated)
                    else
                        print("firesignal not available, trying alternative...")
                        CompleteTradeEvent:FireServer(script_settings.sender, "Accept", script_settings.brainrot, nil)
                    end
                    
                    accepted = true
                    lastAcceptTime = tick()
                    print("Event fired or alternative used, trade should be accepted.")
                end
            end
        else
            accepted = false
        end
    end)
    
    if not isSending then
        local character = Player.Character or Player.CharacterAdded:Wait()
        
        local childAddedConnection = character.ChildAdded:Connect(function(child)
            if child:IsA("Tool") then
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    humanoid:UnequipTools()
                    print("Unequipped received tool: " .. child.Name)
                    
                    if child.Parent == character then
                        child.Parent = Backpack
                        print("Moved " .. child.Name .. " to backpack")
                    end
                end
            end
        end)
        
        table.insert(connections, {type = "childAdded", connection = childAddedConnection})
        
        local unequipLoopConnection = RunService.RenderStepped:Connect(function()
            local character = Player.Character
            if character then
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    local equippedTool = character:FindFirstChildOfClass("Tool")
                    if equippedTool then
                        humanoid:UnequipTools()
                        equippedTool.Parent = Backpack
                        print("Force unequipped and moved to backpack: " .. equippedTool.Name)
                    end
                end
            end
        end)
        
        table.insert(connections, {type = "unequipLoop", connection = unequipLoopConnection})
    end
    
    table.insert(connections, {type = "accept", connection = acceptConnection})
end

local function stopAutoAccept()
    autoAcceptEnabled = false
    
    for i = #connections, 1, -1 do
        if connections[i].type == "accept" or 
           connections[i].type == "childAdded" or 
           connections[i].type == "unequipLoop" then
            connections[i].connection:Disconnect()
            table.remove(connections, i)
        end
    end
    
    updateStatus("Auto Accept Disabled", Color3.fromRGB(255, 100, 100))
end

-- ========== SMART TRADE FUNCTION ==========
local function moveToNextPlayer()
    local nextIndex = script_settings.currentReceiverIndex + 1
    if nextIndex > #script_settings.receivers then
        nextIndex = 1
    end
    script_settings.currentReceiverIndex = nextIndex
    return nextIndex
end

local function getActivePlayer()
    local attempts = 0
    local maxAttempts = #script_settings.receivers * 3
    
    while attempts < maxAttempts do
        local currentIndex = script_settings.currentReceiverIndex
        local receiver = script_settings.receivers[currentIndex]
        
        if receiver and receiver ~= "" then
            local tradeCount = script_settings.tradesPerPlayerCount[receiver] or 0
            
            -- Check if player has already received 100 trades from us
            if tradeCount >= script_settings.tradesPerPlayer then
                updatePlayerStatus(currentIndex, "Completed", tradeCount)
                moveToNextPlayer()
                attempts = attempts + 1
                continue
            end
            
            local playerObj = Players:FindFirstChild(receiver)
            if not playerObj then
                script_settings.playerAttempts[receiver] = (script_settings.playerAttempts[receiver] or 0) + 1
                if script_settings.playerAttempts[receiver] >= 3 then
                    updatePlayerStatus(currentIndex, "Offline", tradeCount)
                    moveToNextPlayer()
                    script_settings.playerAttempts[receiver] = 0
                end
                attempts = attempts + 1
                continue
            end
            
            if not playerObj.Character then
                attempts = attempts + 1
                continue
            end
            
            -- Check if we should skip this receiver (has 100 items or has received 100 trades)
            local shouldSkip, skipReason = shouldSkipReceiver(receiver, playerObj)
            if shouldSkip then
                if skipReason == "inventory_full" then
                    updatePlayerStatus(currentIndex, "Inventory Full", tradeCount)
                    updateStatus(receiver .. " has 100 items (max reached)", Color3.fromRGB(255, 140, 0))
                    moveToNextPlayer()
                elseif skipReason == "completed" then
                    updatePlayerStatus(currentIndex, "Completed", tradeCount)
                    moveToNextPlayer()
                end
                attempts = attempts + 1
                continue
            end
            
            local tradePrompt = playerObj.Character:FindFirstChild("HumanoidRootPart") and 
                               playerObj.Character.HumanoidRootPart:FindFirstChild("TradePrompt")
            if not tradePrompt then
                attempts = attempts + 1
                continue
            end
            
            script_settings.playerAttempts[receiver] = 0
            return receiver, playerObj, currentIndex
        else
            moveToNextPlayer()
            attempts = attempts + 1
        end
    end
    
    return nil
end

local function incrementTradeCount(receiver)
    if script_settings.tradesPerPlayerCount[receiver] then
        script_settings.tradesPerPlayerCount[receiver] = script_settings.tradesPerPlayerCount[receiver] + 1
    else
        script_settings.tradesPerPlayerCount[receiver] = 1
    end
    
    for i, rec in ipairs(script_settings.receivers) do
        if rec == receiver then
            local tradeCount = script_settings.tradesPerPlayerCount[receiver] or 0
            if tradeCount >= script_settings.tradesPerPlayer then
                updatePlayerStatus(i, "Completed", tradeCount)
            else
                updatePlayerStatus(i, "Trading", tradeCount)
            end
            break
        end
    end
    
    updateTotalTrades()
end

local function startSmartTrade()
    if autoTradeRunning then return end
    
    updateStatus("Smart Trade Started", Color3.fromRGB(65, 105, 225))
    autoTradeRunning = true
    
    script_settings.waitingForTradeComplete = false
    script_settings.lastTradeTime = 0
    
    -- Initialize all statuses
    for i, receiver in ipairs(script_settings.receivers) do
        if receiver and receiver ~= "" then
            local tradeCount = script_settings.tradesPerPlayerCount[receiver] or 0
            if tradeCount < script_settings.tradesPerPlayer then
                local playerObj = Players:FindFirstChild(receiver)
                if playerObj then
                    -- Check if receiver inventory is full on startup (100 items)
                    local shouldSkip, skipReason = shouldSkipReceiver(receiver, playerObj)
                    if shouldSkip and skipReason == "inventory_full" then
                        updatePlayerStatus(i, "Inventory Full", tradeCount)
                    else
                        updatePlayerStatus(i, "Waiting", tradeCount)
                    end
                else
                    updatePlayerStatus(i, "Offline", tradeCount)
                end
            else
                updatePlayerStatus(i, "Completed", tradeCount)
            end
        end
    end
    
    local tradeConnection = RunService.Heartbeat:Connect(function()
        -- Check cooldown
        local currentTime = tick()
        if script_settings.waitingForTradeComplete then
            -- Check if trade completed
            local tradeSuccess = checkTradeSuccess()
            if tradeSuccess == true then
                -- Trade was successful, increment counter
                if script_settings.currentTradeReceiver then
                    incrementTradeCount(script_settings.currentTradeReceiver)
                    
                    -- Check if this player has reached their limit
                    local tradeCount = script_settings.tradesPerPlayerCount[script_settings.currentTradeReceiver] or 0
                    if tradeCount >= script_settings.tradesPerPlayer then
                        updateStatus(script_settings.currentTradeReceiver .. " completed (" .. tradeCount .. "/" .. script_settings.tradesPerPlayer .. ")", Color3.fromRGB(50, 205, 50))
                        moveToNextPlayer()
                    end
                end
                script_settings.waitingForTradeComplete = false
                script_settings.currentTradeReceiver = nil
            elseif tradeSuccess == false then
                -- Trade failed
                updateStatus("Trade failed with " .. (script_settings.currentTradeReceiver or "unknown"), Color3.fromRGB(255, 100, 100))
                script_settings.waitingForTradeComplete = false
                script_settings.currentTradeReceiver = nil
            end
            return
        end
        
        if currentTime - script_settings.lastTradeTime < script_settings.tradeCooldown then
            local timeLeft = script_settings.tradeCooldown - (currentTime - script_settings.lastTradeTime)
            updateStatus("Cooldown: " .. math.floor(timeLeft) .. "s", Color3.fromRGB(255, 215, 0))
            return
        end
        
        -- Check if we have items to trade
        local currentInventory = updateInventoryCount()
        if currentInventory <= 0 then
            updateStatus("Out of items", Color3.fromRGB(255, 100, 100))
            stopAutoTrade()
            return
        end
        
        -- Get active player for trading
        local receiver, playerObj, playerIndex = getActivePlayer()
        if not receiver then
            updateStatus("No valid players to trade with", Color3.fromRGB(255, 100, 100))
            return
        end
        
        -- Check if player changed
        if script_settings.currentReceiver ~= receiver then
            script_settings.currentReceiver = receiver
            script_settings.currentReceiverObj = playerObj
            script_settings.currentReceiverIndex = playerIndex
            
            for i, rec in ipairs(script_settings.receivers) do
                if rec == script_settings.currentReceiver then
                    local tradeCount = script_settings.tradesPerPlayerCount[rec] or 0
                    updatePlayerStatus(i, "Trading", tradeCount)
                elseif rec and rec ~= "" then
                    local tradeCount = script_settings.tradesPerPlayerCount[rec] or 0
                    if tradeCount < script_settings.tradesPerPlayer then
                        updatePlayerStatus(i, "Waiting", tradeCount)
                    end
                end
            end
            
            CurrentPlayerLabel.Text = "Current: " .. script_settings.currentReceiver .. " | Progress: " .. 
                                     (script_settings.tradesPerPlayerCount[script_settings.currentReceiver] or 0) .. "/" .. script_settings.tradesPerPlayer
            print("Now trading with: " .. script_settings.currentReceiver)
        end
        
        if not script_settings.currentReceiverObj or not script_settings.currentReceiverObj.Character then
            updateStatus("Waiting for " .. script_settings.currentReceiver, Color3.fromRGB(255, 215, 0))
            return
        end
        
        -- Double-check if we should skip this receiver
        local shouldSkip, skipReason = shouldSkipReceiver(receiver, script_settings.currentReceiverObj)
        if shouldSkip then
            if skipReason == "inventory_full" then
                updateStatus(receiver .. " has 100 items (max reached)", Color3.fromRGB(255, 140, 0))
                updatePlayerStatus(script_settings.currentReceiverIndex, "Inventory Full", script_settings.tradesPerPlayerCount[script_settings.currentReceiver] or 0)
            elseif skipReason == "completed" then
                updatePlayerStatus(script_settings.currentReceiverIndex, "Completed", script_settings.tradesPerPlayerCount[script_settings.currentReceiver] or 0)
            end
            moveToNextPlayer()
            return
        end
        
        local character = Player.Character
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end
        
        -- Find brainrot tool to trade
        local brainrotTool = nil
        local backpackChildren = Backpack:GetChildren()
        
        for i, tool in ipairs(backpackChildren) do
            if i == 2 and tool:IsA("Tool") then
                brainrotTool = tool
                break
            end
        end
        
        if not brainrotTool then
            local equipped = character:FindFirstChildOfClass("Tool")
            if equipped and string.find(equipped.Name, script_settings.brainrot) then
                brainrotTool = equipped
            end
        end
        
        if not brainrotTool then
            updateStatus("No items to trade", Color3.fromRGB(255, 100, 100))
            return
        end
        
        local receiverCharacter = script_settings.currentReceiverObj.Character
        if not receiverCharacter then return end
        local receiverHumanoid = receiverCharacter:FindFirstChildOfClass("Humanoid")
        if not receiverHumanoid or receiverHumanoid.Health <= 0 then return end
        
        local tradePrompt = receiverCharacter:FindFirstChild("HumanoidRootPart") and 
                           receiverCharacter.HumanoidRootPart:FindFirstChild("TradePrompt")
        if not tradePrompt then 
            updateStatus("No trade prompt on " .. script_settings.currentReceiver, Color3.fromRGB(255, 215, 0))
            return 
        end
        
        -- Record inventory before trade
        script_settings.lastInventoryCount = updateInventoryCount()
        script_settings.lastTradeTime = currentTime
        script_settings.waitingForTradeComplete = true
        script_settings.currentTradeReceiver = script_settings.currentReceiver
        
        humanoid:UnequipTools()
        task.wait(0.5)
        
        humanoid:EquipTool(brainrotTool)
        task.wait(0.5)
        
        local equipped = character:FindFirstChildOfClass("Tool")
        if not equipped then 
            print("Failed to equip") 
            script_settings.waitingForTradeComplete = false
            return 
        end
        
        task.wait(1)
        fireproximityprompt(tradePrompt)
        
        updateStatus("Trading with " .. script_settings.currentReceiver .. " (waiting for confirmation)...", Color3.fromRGB(65, 105, 225))
        CurrentPlayerLabel.Text = "Current: " .. script_settings.currentReceiver .. " | Progress: " .. 
                                 (script_settings.tradesPerPlayerCount[script_settings.currentReceiver] or 0) .. "/" .. script_settings.tradesPerPlayer
        
        -- Equip a random tool for next trade (after a delay to not interfere with current trade)
        task.spawn(function()
            task.wait(2)
            local availableTools = {}
            for _, tool in ipairs(Backpack:GetChildren()) do
                if tool:IsA("Tool") and not string.find(tool.Name:lower(), "basic bat") then
                    table.insert(availableTools, tool)
                end
            end
            
            if #availableTools > 0 then
                local randomTool = availableTools[math.random(1, #availableTools)]
                humanoid:EquipTool(randomTool)
            end
        end)
    end)
    
    table.insert(connections, {type = "trade", connection = tradeConnection})
end

local function stopAutoTrade()
    autoTradeRunning = false
    script_settings.waitingForTradeComplete = false
    
    for i = #connections, 1, -1 do
        if connections[i].type == "trade" then
            connections[i].connection:Disconnect()
            table.remove(connections, i)
        end
    end
    
    updateStatus("Smart Trade Stopped", Color3.fromRGB(255, 100, 100))
    CurrentPlayerLabel.Text = "Current: None | Progress: 0/100"
end

-- ========== BUTTON FUNCTIONALITY ==========
AutoTradeButton.MouseButton1Click:Connect(function()
    if not autoTradeRunning then
        startSmartTrade()
        AutoTradeButton.Text = "STOP SMART TRADE"
        AutoTradeButton.BackgroundColor3 = Color3.fromRGB(220, 20, 60)
    else
        stopAutoTrade()
        AutoTradeButton.Text = "START SMART TRADE"
        AutoTradeButton.BackgroundColor3 = Color3.fromRGB(65, 105, 225)
    end
end)

AutoAcceptButton.MouseButton1Click:Connect(function()
    if not autoAcceptEnabled then
        setupAutoAccept()
        AutoAcceptButton.Text = "STOP AUTO ACCEPT"
        AutoAcceptButton.BackgroundColor3 = Color3.fromRGB(220, 20, 60)
    else
        stopAutoAccept()
        AutoAcceptButton.Text = "START AUTO ACCEPT"
        AutoAcceptButton.BackgroundColor3 = Color3.fromRGB(50, 205, 50)
    end
end)

AntiAFKButton.MouseButton1Click:Connect(function()
    if not antiAFKEnabled then
        startAntiAFK()
    else
        stopAntiAFK()
    end
end)

-- ========== HOVER EFFECTS ==========
local function setupButtonHover(button, normalColor, hoverColor)
    button.MouseEnter:Connect(function()
        if (button == AutoTradeButton and not autoTradeRunning) or 
           (button == AutoAcceptButton and not autoAcceptEnabled) or
           (button == AntiAFKButton and not antiAFKEnabled) then
            button.BackgroundColor3 = hoverColor
        end
    end)
    
    button.MouseLeave:Connect(function()
        if button == AutoTradeButton then
            button.BackgroundColor3 = autoTradeRunning and Color3.fromRGB(220, 20, 60) or Color3.fromRGB(65, 105, 225)
        elseif button == AutoAcceptButton then
            button.BackgroundColor3 = autoAcceptEnabled and Color3.fromRGB(220, 20, 60) or Color3.fromRGB(50, 205, 50)
        elseif button == AntiAFKButton then
            button.BackgroundColor3 = antiAFKEnabled and Color3.fromRGB(220, 20, 60) or Color3.fromRGB(138, 43, 226)
        end
    end)
end

setupButtonHover(AutoTradeButton, Color3.fromRGB(65, 105, 225), Color3.fromRGB(75, 115, 235))
setupButtonHover(AutoAcceptButton, Color3.fromRGB(50, 205, 50), Color3.fromRGB(60, 215, 60))
setupButtonHover(AntiAFKButton, Color3.fromRGB(138, 43, 226), Color3.fromRGB(148, 53, 236))

-- TextBox Focus Effects
local function setupTextBoxFocus(textbox)
    textbox.Focused:Connect(function()
        textbox.BackgroundColor3 = Color3.fromRGB(60, 60, 65)
    end)
    
    textbox.FocusLost:Connect(function()
        textbox.BackgroundColor3 = Color3.fromRGB(50, 50, 55)
    end)
end

for _, playerBox in ipairs(playerInputs) do
    setupTextBoxFocus(playerBox)
end
setupTextBoxFocus(ItemsBox)

-- Initialize player status displays
for i, receiver in ipairs(script_settings.receivers) do
    if receiver and receiver ~= "" then
        updatePlayerStatus(i, "Waiting", script_settings.tradesPerPlayerCount[receiver] or 0)
    else
        updatePlayerStatus(i, "Not Set", 0)
    end
end

updateTotalTrades()

-- Initial Status
updateStatus("Ready to start", Color3.fromRGB(200, 200, 200))

print("Smart Sequential Trade GUI Loaded!")
print("Features:")
print("- Trade 100 items with Player 1 FIRST")
print("- Then move to Player 2 for 100 items")
print("- Then Player 3, then Player 4")
print("- Will trade until player has exactly 100 items AND has received 100 trades from us")
print("- ACCURATE COUNTERS: Only counts when inventory decreases")
print("- 5-second cooldown between trades")
print("- Real-time progress tracking")
